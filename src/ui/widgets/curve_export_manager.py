"""
Curve Export Manager - Enhanced export capabilities for geological curves.

Provides professional export features matching 1Point Desktop capabilities:
1. Multi-format export (CSV, Excel, PDF, PNG)
2. Batch export of multiple curves
3. Customizable formatting and layouts
4. Metadata inclusion
5. Quality settings for different use cases
"""

import pandas as pd
import numpy as np
import os
import json
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple
from PyQt6.QtCore import QObject, pyqtSignal, QThread, pyqtSlot
from PyQt6.QtWidgets import QProgressDialog, QMessageBox
from PyQt6.QtGui import QImage, QPainter, QColor, QFont


class ExportWorker(QThread):
    """Worker thread for background export operations."""
    
    progress = pyqtSignal(int, str)  # progress_percentage, status_message
    finished = pyqtSignal(bool, str)  # success, message
    error = pyqtSignal(str)  # error_message
    
    def __init__(self, export_task):
        super().__init__()
        self.export_task = export_task
    
    def run(self):
        """Run the export task in background thread."""
        try:
            self.export_task.execute(self.progress)
            self.finished.emit(True, "Export completed successfully")
        except Exception as e:
            self.error.emit(f"Export failed: {str(e)}")
            self.finished.emit(False, f"Export failed: {str(e)}")


class ExportTask:
    """Base class for export tasks."""
    
    def __init__(self, data: pd.DataFrame, curve_configs: List[Dict], 
                 export_path: str, options: Dict = None):
        self.data = data
        self.curve_configs = curve_configs
        self.export_path = export_path
        self.options = options or {}
        
    def execute(self, progress_signal=None):
        """Execute the export task."""
        raise NotImplementedError("Subclasses must implement execute()")
    
    def _update_progress(self, progress_signal, percent, message):
        """Update progress if signal is provided."""
        if progress_signal:
            progress_signal.emit(percent, message)


class CSVExportTask(ExportTask):
    """Export curves to CSV format."""
    
    def execute(self, progress_signal=None):
        """Export to CSV format."""
        self._update_progress(progress_signal, 10, "Preparing CSV export...")
        
        # Filter visible curves
        visible_curves = [cfg for cfg in self.curve_configs if cfg.get('visible', True)]
        
        # Create export DataFrame
        export_data = {}
        
        # Add depth column if available
        depth_column = self.options.get('depth_column', 'DEPTH')
        if depth_column in self.data.columns:
            export_data[depth_column] = self.data[depth_column]
        
        # Add visible curves
        for i, config in enumerate(visible_curves):
            curve_name = config.get('name', f'Curve_{i}')
            if curve_name in self.data.columns:
                export_data[curve_name] = self.data[curve_name]
            
            percent = 10 + int((i + 1) / len(visible_curves) * 80)
            self._update_progress(progress_signal, percent, f"Adding curve: {curve_name}")
        
        # Create DataFrame
        df_export = pd.DataFrame(export_data)
        
        # Add metadata as comments if requested
        if self.options.get('include_metadata', True):
            metadata = self._generate_metadata()
            # Write metadata as header comments
            with open(self.export_path, 'w') as f:
                for line in metadata:
                    f.write(f"# {line}\n")
                df_export.to_csv(f, index=False)
        else:
            df_export.to_csv(self.export_path, index=False)
        
        self._update_progress(progress_signal, 100, "CSV export complete")
    
    def _generate_metadata(self):
        """Generate metadata for export file."""
        metadata = [
            f"Earthworm Curve Export - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"Generated by Earthworm Borehole Logger v{self.options.get('version', '1.0')}",
            f"Number of curves: {len([c for c in self.curve_configs if c.get('visible', True)])}",
            f"Total data points: {len(self.data)}",
            ""
        ]
        
        # Add curve information
        metadata.append("Curve Configuration:")
        for config in self.curve_configs:
            if config.get('visible', True):
                metadata.append(f"  - {config.get('name', 'Unknown')}: "
                              f"Color={config.get('color', '#000000')}, "
                              f"Style={config.get('line_style', 'solid')}, "
                              f"Thickness={config.get('thickness', 1.0)}")
        
        return metadata


class ExcelExportTask(ExportTask):
    """Export curves to Excel format with formatting."""
    
    def execute(self, progress_signal=None):
        """Export to Excel format with formatting."""
        try:
            import openpyxl
            from openpyxl.styles import Font, PatternFill, Alignment, Border, Side
            from openpyxl.utils import get_column_letter
        except ImportError:
            raise ImportError("openpyxl is required for Excel export. Install with: pip install openpyxl")
        
        self._update_progress(progress_signal, 10, "Preparing Excel export...")
        
        # Filter visible curves
        visible_curves = [cfg for cfg in self.curve_configs if cfg.get('visible', True)]
        
        # Create workbook
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "Curve Data"
        
        # Write metadata
        self._write_excel_metadata(ws)
        
        # Write headers
        headers = ['Depth'] + [cfg.get('name', f'Curve_{i}') for i, cfg in enumerate(visible_curves)]
        for col_idx, header in enumerate(headers, 1):
            cell = ws.cell(row=5, column=col_idx, value=header)
            cell.font = Font(bold=True)
            cell.fill = PatternFill(start_color="CCCCCC", end_color="CCCCCC", fill_type="solid")
            cell.alignment = Alignment(horizontal="center")
        
        # Write data
        depth_column = self.options.get('depth_column', 'DEPTH')
        if depth_column not in self.data.columns:
            raise ValueError(f"Depth column '{depth_column}' not found in data")
        
        total_rows = len(self.data)
        for row_idx, (_, row) in enumerate(self.data.iterrows(), 6):
            # Write depth
            ws.cell(row=row_idx, column=1, value=row[depth_column])
            
            # Write curve values
            for col_idx, config in enumerate(visible_curves, 2):
                curve_name = config.get('name')
                if curve_name in self.data.columns:
                    ws.cell(row=row_idx, column=col_idx, value=row[curve_name])
            
            # Update progress
            if row_idx % 100 == 0:
                percent = 20 + int((row_idx - 5) / total_rows * 70)
                self._update_progress(progress_signal, percent, f"Writing row {row_idx}/{total_rows + 5}")
        
        # Apply formatting
        self._apply_excel_formatting(ws, len(headers), total_rows + 5)
        
        # Add summary sheet
        self._add_summary_sheet(wb, visible_curves)
        
        # Save workbook
        wb.save(self.export_path)
        
        self._update_progress(progress_signal, 100, "Excel export complete")
    
    def _write_excel_metadata(self, worksheet):
        """Write metadata to Excel worksheet."""
        metadata = [
            ["Earthworm Borehole Logger - Curve Export"],
            [f"Export Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"],
            [f"Software Version: {self.options.get('version', '1.0')}"],
            [f"Total Curves: {len([c for c in self.curve_configs if c.get('visible', True)])}"],
            [f"Data Points: {len(self.data)}"],
            []
        ]
        
        for row_idx, row_data in enumerate(metadata, 1):
            worksheet.cell(row=row_idx, column=1, value=row_data[0])
            worksheet.cell(row=row_idx, column=1).font = Font(bold=True)
    
    def _apply_excel_formatting(self, worksheet, num_columns, num_rows):
        """Apply formatting to Excel worksheet."""
        # Set column widths
        for col in range(1, num_columns + 1):
            column_letter = get_column_letter(col)
            if col == 1:  # Depth column
                worksheet.column_dimensions[column_letter].width = 12
            else:
                worksheet.column_dimensions[column_letter].width = 15
        
        # Add borders to data area
        thin_border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
        
        for row in range(5, num_rows + 1):
            for col in range(1, num_columns + 1):
                worksheet.cell(row=row, column=col).border = thin_border
        
        # Freeze headers
        worksheet.freeze_panes = "A6"
    
    def _add_summary_sheet(self, workbook, visible_curves):
        """Add summary sheet to workbook."""
        ws_summary = workbook.create_sheet(title="Summary")
        
        # Write curve summary
        ws_summary.cell(row=1, column=1, value="Curve Summary").font = Font(bold=True, size=14)
        
        headers = ["Curve Name", "Color", "Line Style", "Thickness", "Visible", "Data Points", "Min Value", "Max Value", "Mean Value"]
        for col_idx, header in enumerate(headers, 1):
            ws_summary.cell(row=3, column=col_idx, value=header).font = Font(bold=True)
        
        for row_idx, config in enumerate(visible_curves, 4):
            curve_name = config.get('name', 'Unknown')
            
            # Calculate statistics if curve exists in data
            if curve_name in self.data.columns:
                curve_data = self.data[curve_name].dropna()
                data_points = len(curve_data)
                min_val = curve_data.min() if data_points > 0 else None
                max_val = curve_data.max() if data_points > 0 else None
                mean_val = curve_data.mean() if data_points > 0 else None
            else:
                data_points = 0
                min_val = max_val = mean_val = None
            
            ws_summary.cell(row=row_idx, column=1, value=curve_name)
            ws_summary.cell(row=row_idx, column=2, value=config.get('color', '#000000'))
            ws_summary.cell(row=row_idx, column=3, value=config.get('line_style', 'solid'))
            ws_summary.cell(row=row_idx, column=4, value=config.get('thickness', 1.0))
            ws_summary.cell(row=row_idx, column=5, value=config.get('visible', True))
            ws_summary.cell(row=row_idx, column=6, value=data_points)
            ws_summary.cell(row=row_idx, column=7, value=min_val)
            ws_summary.cell(row=row_idx, column=8, value=max_val)
            ws_summary.cell(row=row_idx, column=9, value=mean_val)
        
        # Auto-size columns
        for col in ws_summary.columns:
            max_length = 0
            column = col[0].column_letter
            for cell in col:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)
            ws_summary.column_dimensions[column].width = adjusted_width


class CurveExportManager(QObject):
    """Manager for curve export operations."""
    
    exportProgress = pyqtSignal(int, str)  # progress_percentage, status_message
    exportFinished = pyqtSignal(bool, str)  # success, message
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.export_worker = None
        self.current_task = None
        
    def export_curves(self, data: pd.DataFrame, curve_configs: List[Dict], 
                     export_path: str, format_type: str = 'csv', 
                     options: Dict = None):
        """
        Export curves to specified format.
        
        Args:
            data: DataFrame containing curve data
            curve_configs: List of curve configuration dictionaries
            export_path: Path to save exported file
            format_type: Export format ('csv', 'excel', 'pdf', 'png')
            options: Additional export options
        """
        # Validate inputs
        if data is None or data.empty:
            self.exportFinished.emit(False, "No data to export")
            return
        
        if not curve_configs:
            self.exportFinished.emit(False, "No curve configurations provided")
            return
        
        # Create export task based on format
        format_type = format_type.lower()
        if format_type == 'csv':
            task = CSVExportTask(data, curve_configs, export_path, options)
        elif format_type == 'excel':
            task = ExcelExportTask(data, curve_configs, export_path, options)
        elif format_type == 'pdf':
            # PDF export would require additional dependencies
            self.exportFinished.emit(False, "PDF export not yet implemented")
            return
        elif format_type == 'png':
            # PNG export would require rendering and saving
            self.exportFinished.emit(False, "PNG export not yet implemented")
            return
        else:
            self.exportFinished.emit(False, f"Unsupported format: {format_type}")
            return
        
        # Create and start worker thread
        self.current_task = task
        self.export_worker = ExportWorker(task)
        self.export_worker.progress.connect(self.exportProgress)
        self.export_worker.finished.connect(self._on_export_finished)
        self.export_worker.error.connect(self._on_export_error)
        self.export_worker.start()
    
    @pyqtSlot(bool, str)
    def _on_export_finished(self, success, message):
        """Handle export completion."""
        self.exportFinished.emit(success, message)
        self.export_worker = None
        self.current_task = None
    
    @pyqtSlot(str)
    def _on_export_error(self, error_message):
        """Handle export error."""
        self.exportFinished.emit(False, error_message)
        self.export_worker = None
        self.current_task = None
    
    def cancel_export(self):
        """Cancel current export operation."""
        if self.export_worker and self.export_worker.isRunning():
            self.export_worker.terminate()
            self.export_worker.wait()
            self.exportFinished.emit(False, "Export cancelled by user")
            self.export_worker = None
            self.current_task = None
    
    def get_supported_formats(self):
        """Get list of supported export formats."""
        return [
            {'id': 'csv', 'name': 'CSV (Comma Separated Values)', 'extension': '*.csv'},
            {'id': 'excel', 'name': 'Excel Workbook', 'extension': '*.xlsx'},
            # {'id': 'pdf', 'name': 'PDF Report', 'extension': '*.pdf'},
            # {'id': 'png', 'name': 'PNG Image', 'extension': '*.png'}
        ]
    
    def get_default_options(self, format_type):
        """Get default options for export format."""
        defaults = {
            'include_metadata': True,
            'depth_column': 'DEPTH',
            'version': '1.0'
        }
        
        if format_type == 'excel':
            defaults.update({
                'include_summary': True,
                'apply_formatting': True,
                'freeze_headers': True
            })
        
        return defaults


# Factory function for easy integration
def create_curve_export_manager(parent=None):
    """Create and initialize a curve export manager."""
    manager = CurveExportManager(parent)
    return manager